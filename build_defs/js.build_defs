"""Rules to build JavaScript and TypeScript code.

JavaScript has a module-based architecture, so rules map naturally to npm-style
packages and entry points.
"""


def js_toolchain(name:str, version:str, hashes:list=None, visibility:list=["PUBLIC"]):
    """Downloads a Node.js SDK and exposes node, npm, and npx entry points.

    To use this rule, add the following to your .plzconfig:
        [Plugin "js"]
        NodeTool = //third_party/js:<name>|node

    Args:
        name: Name of the rule.
        version: Node.js version to download (e.g. "20.11.0").
        hashes: Optional hashes for the download.
        visibility: Visibility specification.
    """
    arch = _node_arch()
    url = f"https://nodejs.org/dist/v{version}/node-v{version}-{CONFIG.OS}-{arch}.tar.gz"

    download = remote_file(
        name = tag(name, "download"),
        url = url,
        hashes = hashes,
    )

    return build_rule(
        name = name,
        srcs = [download],
        cmd = "tar -xf $SRCS && mv node-v* $OUT",
        outs = [name],
        entry_points = {
            "node": f"{name}/bin/node",
            "npm": f"{name}/lib/node_modules/npm/bin/npm-cli.js",
            "npx": f"{name}/lib/node_modules/npm/bin/npx-cli.js",
        },
        binary = True,
        visibility = visibility,
        building_description = "Installing Node.js...",
    )


def js_library(name:str, srcs:list, deps:list=[], module_name:str="",
               entry_point:str="index.js", visibility:list=None,
               test_only:bool&testonly=False, labels:list=[]):
    """Compiles JavaScript or TypeScript sources into a library.

    Each js_library produces:
    1. An output directory with transpiled sources (TS/JSX -> JS)
    2. A .moduleconfig file mapping module_name -> output_path

    The .moduleconfig mechanism is inspired by go-rules' .importconfig:
    each library produces a config fragment, and js_binary aggregates
    them all to set up module resolution at bundle time.

    Args:
        name: Name of the rule.
        srcs: Source files (.js, .jsx, .ts, .tsx, .json).
        deps: Dependencies (other js_library or npm_module targets).
        module_name: Module name for package imports. Defaults to the package path.
        entry_point: Entry point file within the library.
        visibility: Visibility specification.
        test_only: If True, only visible to test rules.
        labels: Additional labels.
    """
    module_name = module_name or package_name()

    return build_rule(
        name = name,
        srcs = srcs,
        deps = deps,
        outs = {
            "lib": [name],
            "moduleconfig": [f"{name}.moduleconfig"],
        },
        cmd = " && ".join([
            "mkdir -p $OUTS_LIB",
            "$TOOLS_PLEASE_JS transpile --out-dir $OUTS_LIB $SRCS",
            f'echo "{module_name}=$PKG_DIR/{name}" > $OUTS_MODULECONFIG',
        ]),
        tools = {"please_js": [CONFIG.JS.PLEASE_JS_TOOL]},
        visibility = visibility,
        test_only = test_only,
        labels = labels + [f"js_module:{module_name}"],
        exported_deps = deps,
        building_description = "Compiling...",
    )


def js_binary(name:str, entry_point:str="index.js", srcs:list=[], deps:list=[],
              format:str="esm", platform:str="browser", visibility:list=None,
              labels:list=[]):
    """Bundles JavaScript/TypeScript into a single output file.

    Aggregates all .moduleconfig files from transitive dependencies,
    then runs please_js bundle to produce the final bundle using esbuild.

    Args:
        name: Name of the rule.
        entry_point: Entry point source file.
        srcs: Additional source files.
        deps: Dependencies (js_library, npm_module targets).
        format: Output format: esm, cjs, iife.
        platform: Target platform: browser, node.
        visibility: Visibility specification.
        labels: Additional labels.
    """
    moduleconfig_flag = "--moduleconfig moduleconfig"

    bundle_cmd = " && ".join([
        _aggregate_moduleconfig_cmd(),
        f"$TOOLS_PLEASE_JS bundle --entry $PKG_DIR/{entry_point} {moduleconfig_flag} --out _bundle.js --format {format} --platform {platform}",
    ])

    if platform == "node":
        cmd = f'{bundle_cmd} && echo "#!/usr/bin/env node" > $OUT && cat _bundle.js >> $OUT'
    else:
        cmd = f'{bundle_cmd} && mv _bundle.js $OUT'

    return build_rule(
        name = name,
        srcs = [entry_point] + srcs,
        deps = deps,
        outs = [f"{name}.js"],
        cmd = cmd,
        tools = {"please_js": [CONFIG.JS.PLEASE_JS_TOOL]},
        binary = True,
        needs_transitive_deps = True,
        visibility = visibility,
        labels = labels,
        building_description = "Bundling...",
    )


def js_test(name:str, srcs:list, entry_point:str=None, deps:list=[],
            dev_deps:list=[], visibility:list=None, labels:list=[],
            timeout:int=0, flaky:bool|int=0, size:str=None):
    """Bundles and runs JavaScript tests using Node.js.

    Args:
        name: Name of the rule.
        srcs: Test source files.
        entry_point: Test entry point. Defaults to first file in srcs.
        deps: Dependencies.
        dev_deps: Development-only dependencies (test frameworks, mocking tools).
        visibility: Visibility specification.
        labels: Additional labels.
        timeout: Test timeout in seconds.
        flaky: True to mark the test as flaky, or an integer for reruns.
        size: Test size (enormous, large, medium, small).
    """
    entry_point = entry_point or srcs[0]

    tools = {"please_js": [CONFIG.JS.PLEASE_JS_TOOL]}
    if CONFIG.JS.NODE_TOOL:
        tools["node"] = [CONFIG.JS.NODE_TOOL]
        test_cmd = "$TOOLS_NODE $TEST"
    else:
        test_cmd = "node $TEST"

    return build_rule(
        name = name,
        srcs = srcs,
        deps = deps + dev_deps,
        outs = [f"{name}.js"],
        test = True,
        no_test_output = True,
        cmd = " && ".join([
            _aggregate_moduleconfig_cmd(),
            f"$TOOLS_PLEASE_JS bundle --entry $PKG_DIR/{entry_point} --moduleconfig moduleconfig --out $OUT --format cjs --platform node",
        ]),
        test_cmd = test_cmd,
        tools = tools,
        needs_transitive_deps = True,
        visibility = visibility,
        labels = labels,
        test_timeout = timeout,
        flaky = flaky,
        size = size,
        building_description = "Bundling test...",
    )


def npm_module(name:str, pkg_name:str="", version:str="", deps:list=[],
               hashes:list=None, visibility:list=["PUBLIC"], labels:list=[],
               entry_point:str=""):
    """Downloads an npm package and makes it available as a dependency.

    Downloads a package tarball from the npm registry, extracts it, and
    produces a .moduleconfig file so that js_binary can resolve imports.

    Args:
        name: Name of the rule.
        pkg_name: npm package name (e.g. "react", "@babel/core"). Defaults to name.
        version: Exact version to fetch.
        deps: Dependencies on other npm_module targets (for transitive deps).
        hashes: Optional hashes for the download.
        visibility: Visibility specification.
        labels: Additional labels.
        entry_point: Override the package entry point.
    """
    pkg = pkg_name or name
    if not version:
        fail("version is required for npm_module")

    # npm tarball URL: scoped packages use @scope/pkg/-/pkg-ver.tgz
    pkg_basename = pkg.split("/")[-1] if "/" in pkg else pkg
    if pkg.startswith("@"):
        url = f"https://registry.npmjs.org/{pkg}/-/{pkg_basename}-{version}.tgz"
    else:
        url = f"https://registry.npmjs.org/{pkg}/-/{pkg}-{version}.tgz"

    download = remote_file(
        name = tag(name, "download"),
        url = url,
        out = f"_{name}_dl",
        hashes = hashes,
        extract = True,
    )

    return build_rule(
        name = name,
        srcs = [download],
        outs = {
            "lib": [name],
            "moduleconfig": [f"{name}.moduleconfig"],
        },
        cmd = " && ".join([
            "mkdir -p $OUTS_LIB",
            # npm tarballs extract to a package/ subdirectory
            "if [ -d $SRCS/package ]; then cp -r $SRCS/package/. $OUTS_LIB/; else cp -r $SRCS/. $OUTS_LIB/; fi",
            f'echo "{pkg}=$PKG_DIR/{name}" > $OUTS_MODULECONFIG',
        ]),
        exported_deps = deps,
        visibility = visibility,
        labels = labels + [f"npm_module:{pkg}@{version}"],
        building_description = "Installing npm package...",
    )


def npm_repo(name:str, package_lock:str, no_dev:bool=False,
             subinclude_path:str="///js//build_defs:js",
             visibility:list=["PUBLIC"]):
    """Creates a subrepo of npm_module rules from a package-lock.json.

    Reads the lockfile, generates npm_module rules for each package,
    and registers them as a Please subrepo. Users can then reference
    packages as ///name//package_name.

    By default, all packages (including devDependencies) are included,
    matching the behavior of npm install / Vite / webpack. Dev-only
    packages are labeled with npm:dev for identification.

    Args:
        name: Subrepo name (referenced as ///name//package).
        package_lock: Path to package-lock.json file.
        no_dev: Exclude dev dependencies from the generated subrepo.
        subinclude_path: Path to js build_defs for generated BUILD files.
                         Use "//build_defs:js" when developing js-rules itself.
        visibility: Visibility specification.
    """
    dev_flag = " --no-dev" if no_dev else ""

    repo = build_rule(
        name = tag(name, "repo"),
        srcs = [package_lock],
        cmd = f"$TOOLS_PLEASE_JS resolve --lockfile $SRCS --out $OUT{dev_flag} --subinclude-path {subinclude_path}",
        outs = [name],
        tools = {"please_js": [CONFIG.JS.PLEASE_JS_TOOL]},
        output_is_complete = True,
        visibility = visibility,
        building_description = "Resolving npm dependencies...",
    )

    subrepo(
        name = name,
        dep = repo,
    )


def tailwind_toolchain(name:str, version:str, hashes:list=None, visibility:list=["PUBLIC"]):
    """Downloads the Tailwind CSS standalone CLI binary.

    Args:
        name: Name of the rule.
        version: Tailwind CSS version to download (e.g. "3.4.17").
        hashes: Optional hashes for the download.
        visibility: Visibility specification.
    """
    os_name = "macos" if CONFIG.OS == "darwin" else CONFIG.OS
    arch = "x64" if CONFIG.ARCH == "amd64" else CONFIG.ARCH
    url = f"https://github.com/tailwindlabs/tailwindcss/releases/download/v{version}/tailwindcss-{os_name}-{arch}"

    return remote_file(
        name = name,
        url = url,
        hashes = hashes,
        binary = True,
        visibility = visibility,
    )


def tailwind_css(name:str, src:str, content_srcs:list=[], deps:list=[],
                 config:str="", minify:bool=True, visibility:list=None):
    """Compiles Tailwind CSS using the standalone CLI.

    Runs the Tailwind CSS standalone binary on the input CSS file,
    scanning content_srcs for utility class names. Produces optimized
    CSS containing only the classes actually used.

    Args:
        name: Name of the rule.
        src: Input CSS file (e.g. containing @tailwind directives or @import "tailwindcss").
        content_srcs: Source files to scan for utility classes (HTML, JSX, TSX).
        deps: Dependencies (e.g. other CSS files).
        config: Optional tailwind.config.js for v3 compatibility.
        minify: Whether to minify the output.
        visibility: Visibility specification.
    """
    minify_flag = "--minify" if minify else ""
    config_flag = f"--config $PKG_DIR/{config}" if config else ""

    srcs = {"css": [src], "content": content_srcs}
    if config:
        srcs["config"] = [config]

    return build_rule(
        name = name,
        srcs = srcs,
        deps = deps,
        outs = [f"{name}.css"],
        cmd = f"CONTENT=$(echo $SRCS_CONTENT | tr ' ' ',') && $TOOLS_TAILWIND --input $SRCS_CSS --output $OUT --content $CONTENT {minify_flag} {config_flag}".strip(),
        tools = {"tailwind": [CONFIG.JS.TAILWIND_TOOL]},
        visibility = visibility,
        building_description = "Compiling Tailwind CSS...",
    )


def js_dev_server(name:str, entry_point:str, srcs:list=[], deps:list=[],
                  dev_deps:list=[], servedir:str=".", port:int=8080,
                  format:str="esm", platform:str="browser",
                  visibility:list=None):
    """Creates a runnable dev server target with live reload.

    At build time, aggregates moduleconfigs from dependencies.
    At run time (plz run), starts an esbuild dev server that watches
    real source files for changes and live-reloads the browser.

    Args:
        name: Name of the rule.
        entry_point: Entry point source file (e.g. "src/main.jsx").
        srcs: Additional source files.
        deps: Production dependencies (js_library, npm_module targets).
        dev_deps: Development-only dependencies (testing tools, dev plugins).
                  These are included in the dev server but not in js_binary.
        servedir: Directory to serve static files from, relative to package.
        port: HTTP port for the dev server.
        format: Output format: esm, cjs, iife.
        platform: Target platform: browser, node.
        visibility: Visibility specification.
    """
    # Build step: aggregate moduleconfigs, base64-encode them, and produce a
    # shell script. At runtime (plz run), the script decodes the moduleconfig,
    # then starts please_js dev pointing at real source files for live reload.
    #
    # Single-quoted echo args pass $MODCONF literally into the output script.
    # Break out to double-quoted "$VAR" for build-time expansion of $PKG_DIR,
    # $PLEASE_JS, and $MODCONF_B64.
    agg_cmd = _aggregate_moduleconfig_cmd()
    # Resolve moduleconfig paths to absolute plz-out paths. In the build sandbox,
    # dep dirs are symlinks to plz-out, so readlink -f gives the real location.
    resolve_cmd = "while IFS='=' read -r name path; do echo \"$name=$(readlink -f $path)\"; done < moduleconfig > moduleconfig_abs && mv moduleconfig_abs moduleconfig"
    cmd = " && ".join([
        agg_cmd,
        resolve_cmd,
        "MODCONF_B64=$(base64 -w0 moduleconfig)",
        "PLEASE_JS=$(readlink -f $TOOLS_PLEASE_JS)",
        "echo '#!/bin/bash' > $OUT",
        "echo 'set -euo pipefail' >> $OUT",
        "echo 'MODCONF=$(mktemp)' >> $OUT",
        "echo 'trap \"rm -f $MODCONF\" EXIT' >> $OUT",
        "echo 'echo '\"$MODCONF_B64\"' | base64 -d > $MODCONF' >> $OUT",
        f"echo 'exec '\"$PLEASE_JS\"' dev --entry '\"$PKG_DIR\"'/{entry_point} --moduleconfig $MODCONF --servedir '\"$PKG_DIR\"'/{servedir} --port {port} --format {format} --platform {platform}' >> $OUT",
        "chmod +x $OUT",
    ])

    return build_rule(
        name = name,
        srcs = [entry_point] + srcs,
        deps = deps + dev_deps,
        outs = [f"{name}.sh"],
        cmd = cmd,
        tools = {"please_js": [CONFIG.JS.PLEASE_JS_TOOL]},
        binary = True,
        needs_transitive_deps = True,
        visibility = visibility,
        building_description = "Preparing dev server...",
    )


def _aggregate_moduleconfig_cmd():
    """Returns a command that aggregates all .moduleconfig files from deps."""
    return 'touch moduleconfig && find . -name "*.moduleconfig" -exec cat {} + | sort -u >> moduleconfig'


def _node_arch():
    """Maps Please arch to Node.js arch naming."""
    if CONFIG.ARCH == "amd64":
        return "x64"
    elif CONFIG.ARCH == "arm64":
        return "arm64"
    return CONFIG.ARCH
